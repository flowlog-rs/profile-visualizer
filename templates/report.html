<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FlowLog Profile Viz</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
    }

    header {
      padding: 12px 16px;
      border-bottom: 1px solid #ddd;
    }

    .container {
      display: flex;
      height: calc(100vh - 58px);
    }

    .sidebar {
      width: 450px;
      border-right: 1px solid #ddd;
      padding: 12px;
      overflow: auto;
    }

    .main {
      flex: 1;
      padding: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .summary {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      font-size: 14px;
      color: #333;
    }

    .pill {
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 999px;
      background: #fafafa;
    }

    .legend {
      display: flex;
      gap: 12px;
      align-items: center;
      font-size: 13px;
      color: #444;
      flex-wrap: wrap;
      margin-bottom: 6px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend-swatch {
      width: 160px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid #ccd3e0;
      background: linear-gradient(90deg, rgb(233, 242, 255) 0%, rgb(91, 141, 239) 100%);
    }

    .legend-swatch-red {
      width: 160px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid #e0ccd0;
      background: linear-gradient(90deg, rgb(255, 255, 255) 0%, rgb(220, 30, 30) 100%);
    }

    .tree-node {
      cursor: pointer;
      user-select: none;
      padding: 2px 4px;
      border-radius: 4px;
    }

    .tree-node:hover {
      background: #f3f3f3;
    }

    .tree-node.selected {
      background: #e9f2ff;
      border: 1px solid #cfe3ff;
    }

    .indent {
      display: inline-block;
      width: 16px;
    }

    .toggle {
      display: inline-block;
      width: 16px;
      text-align: center;
      color: #666;
    }

    .muted {
      color: #777;
      font-size: 12px;
    }

    #rulePicker {
      margin: 8px 0 10px;
      font-size: 16px;
      line-height: 1.4;
    }

    .rule-list {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .rule-item {
      text-align: left;
      padding: 6px 10px;
      border: 1px solid #ddd;
      background: #fafafa;
      border-radius: 6px;
      cursor: pointer;
      font-size: 15px;
    }

    .rule-item.active {
      background: #e9f2ff;
      border-color: #cfe3ff;
      font-weight: 600;
    }

    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .tab {
      padding: 6px 10px;
      border: 1px solid #ddd;
      background: #f8f8f8;
      border-radius: 6px;
      cursor: pointer;
    }

    .tab.active {
      background: #e9f2ff;
      border-color: #cfe3ff;
    }

    .toplist {
      margin: 10px 0 14px;
      padding: 8px;
      border: 1px solid #eee;
      border-radius: 8px;
      background: #fafafa;
    }

    .toplist-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .toplist-item {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      padding: 4px 6px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
    }

    .toplist-item:hover {
      background: #f0f4ff;
    }

    .toplist-item.active {
      background: #e9f2ff;
      border: 1px solid #cfe3ff;
    }

    .toplist-name {
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .toplist-ms {
      font-variant-numeric: tabular-nums;
      color: #333;
    }

    #graphPane {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #graphView {
      flex: 1;
      width: 100%;
      height: 100%;
      min-height: 420px;
      border: 1px solid #eee;
      border-radius: 8px;
      overflow: auto;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    #graphView svg {
      cursor: grab;
    }

    #graphView svg:active {
      cursor: grabbing;
    }

    #graphView svg {
      will-change: transform;
    }

    .g-edge {
      stroke: #8fa3c7;
      stroke-width: 1.2;
      fill: none;
      pointer-events: none;
      opacity: 0.8;
    }

    .g-edge.dim {
      opacity: 0.15;
    }

    .g-edge.highlight {
      stroke: #2f5bd3;
      stroke-width: 2;
      opacity: 1;
    }

    .g-block rect {
      fill: rgba(248, 250, 255, 0.6);
      stroke: #c9d7ff;
      stroke-width: 1;
      stroke-dasharray: 6 4;
      rx: 10;
      ry: 10;
    }

    .g-node rect {
      rx: 6;
      ry: 6;
      stroke: #5570d4;
      stroke-width: 1;
    }

    .g-node text {
      font-size: 12px;
      fill: #111;
      pointer-events: none;
    }

    .g-node.selected rect {
      stroke: #111;
      stroke-width: 2;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 8px;
    }

    th,
    td {
      border-bottom: 1px solid #eee;
      padding: 6px 8px;
      text-align: left;
      font-size: 14px;
    }

    th {
      position: sticky;
      top: 0;
      background: white;
      border-bottom: 1px solid #ddd;
    }

    .num {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 13px;
    }
  </style>
</head>

<body>
  <header>
    <div class="summary" id="summary"></div>
  </header>

  <div class="container">
    <div class="sidebar">
      <div style="display:flex; gap: 8px; margin-bottom: 8px;">
        <input id="search" placeholder="Search name..."
          style="flex:1; padding: 6px 8px; border: 1px solid #ddd; border-radius: 6px;">
        <button id="expandAll" style="padding: 6px 10px;">Expand</button>
        <button id="collapseAll" style="padding: 6px 10px;">Collapse</button>
      </div>
      <div class="toplist">
        <div class="toplist-title">Top 10 Operators</div>
        <div id="topNodes"></div>
      </div>
      <div id="tree"></div>
    </div>

    <div class="main">
      <div class="tabs" style="justify-content:space-between;">
        <div style="display:flex;gap:8px;">
          <button class="tab active" id="tabTree">Nodes</button>
          <button class="tab" id="tabGraph">Graph</button>
        </div>
        <div id="modeToggle" style="display:none;gap:4px;align-items:center;">
          <span style="font-size:13px;color:#555;">Show:</span>
          <button class="tab active" id="modeTime">Time</button>
          <button class="tab" id="modeMemory">Memory</button>
        </div>
      </div>

      <div id="detailPane">
        <h2 id="title">Select a node</h2>
        <div id="meta" class="muted"></div>
        <div id="rulePicker"></div>

        <table id="opsTable" style="display:none;">
          <thead id="opsTableHead">
            <tr>
              <th>addr</th>
              <th>operator</th>
              <th class="num">activations</th>
              <th class="num">active time</th>
            </tr>
          </thead>
          <tbody id="opsBody"></tbody>
        </table>
      </div>

      <div id="graphPane" style="display:none;">
        <div id="legend" class="legend"></div>
        <div id="graphView"></div>
      </div>
    </div>
  </div>

  <script>
    // Embedded report data (JSON object literal)
    const DATA = __DATA__;

    const state = {
      expanded: new Set(),
      selected: null,
      selectedRule: null,
      search: "",
      view: "tree",
      graph: { tx: 0, ty: 0, scale: 1 }, // pan/zoom
      defaultExpanded: true,
      displayMode: "time", // "time" or "memory"
    };

    // Unique key for rule plan nodes (rule text + fingerprint).
    const planKey = (ruleText, fp) => `${ruleText}::${fp}`;

    const NODE = {
      padX: 12,
      padY: 8,
      lineH: 16,
      minW: 140,
      maxW: 360,
      minH: 36,
      font: "12px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif",
    };

    const _measureCanvas = document.createElement("canvas");
    const _measureCtx = _measureCanvas.getContext("2d");

    function fmtMs(x) {
      return (Math.round(x * 1000) / 1000).toFixed(3);
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function measureTextPx(s) {
      _measureCtx.font = NODE.font;
      return _measureCtx.measureText(String(s)).width;
    }

    function wrapLines(text, maxContentW) {
      const words = String(text).split(/\s+/).filter(Boolean);
      if (!words.length) return [""];

      const lines = [];
      let cur = words[0];

      for (let i = 1; i < words.length; i++) {
        const next = `${cur} ${words[i]}`;
        if (measureTextPx(next) <= maxContentW) {
          cur = next;
        } else {
          lines.push(cur);
          cur = words[i];
        }
      }
      lines.push(cur);
      return lines;
    }

    function nodeBox(label) {
      const maxContentW = NODE.maxW - 2 * NODE.padX;
      const lines = wrapLines(label, maxContentW);

      const contentW = Math.min(
        maxContentW,
        Math.max(...lines.map(measureTextPx), 0)
      );

      const w = Math.max(NODE.minW, Math.min(NODE.maxW, contentW + 2 * NODE.padX));
      const h = Math.max(NODE.minH, lines.length * NODE.lineH + 2 * NODE.padY);
      return { w, h, lines };
    }

    function renderSummary() {
      const t = DATA.totals;
      const el = document.getElementById("summary");
      const memPill = `<span class="pill">total batched_in: <b>${t.total_batched_in.toLocaleString()}</b></span>`;
      el.innerHTML = `
    <span class="pill">names: <b>${t.names}</b></span>
    <span class="pill">operators in time log: <b>${t.operators_in_time}</b></span>
    <span class="pill">operators mapped: <b>${t.operators_mapped}</b></span>
    <span class="pill">mapped ms: <b>${fmtMs(t.total_mapped_ms)}</b></span>
    <span class="pill">mapped activations: <b>${t.total_mapped_activations}</b></span>
    ${memPill}
  `;
    }

    function nodeMatches(name, node) {
      if (!state.search) return true;
      const s = state.search.toLowerCase();
      return (
        name.toLowerCase().includes(s) ||
        (node.label || "").toLowerCase().includes(s)
      );
    }

    function rulesForFingerprint(fp) {
      if (!fp) return [];
      const out = [];
      for (const r of DATA.rules || []) {
        if (r.nodes && r.nodes[fp]) out.push(r.text);
      }
      return out;
    }

    function findRuleByText(text) {
      if (!text) return null;
      return (DATA.rules || []).find((r) => r.text === text) || null;
    }

    function renderTree() {
      const root = document.getElementById("tree");
      root.innerHTML = "";

      const nodes = DATA.nodes;
      const rules = DATA.rules || [];
      const rulesByText = new Map(rules.map((r) => [r.text, r]));

      const autoExpand = !state.defaultExpanded && state.expanded.size === 0;

      const idOf = (name) => {
        const n = parseInt(name, 10);
        return Number.isNaN(n) ? null : n;
      };
      const cmpById = (a, b) => {
        const ia = idOf(a);
        const ib = idOf(b);
        if (ia !== null && ib !== null && ia !== ib) return ia - ib;
        if (ia !== null && ib === null) return -1;
        if (ia === null && ib !== null) return 1;
        return a.localeCompare(b);
      };

      const blocks = new Map(); // block -> [names]
      for (const [name, node] of Object.entries(nodes)) {
        const blk = (node.block || "other").toString();
        if (!blocks.has(blk)) blocks.set(blk, []);
        blocks.get(blk).push(name);
      }

      // Order blocks: input, stratum N ascending, inspect, other.
      const blockOrder = (b) => {
        const l = b.toLowerCase();
        if (l.startsWith("input")) return [0, 0];
        const m = l.match(/^stratum\s*(\d+)/);
        if (m) return [1, parseInt(m[1], 10)];
        if (l.includes("inspect")) return [2, 0];
        return [3, b];
      };
      const sortedBlocks = Array.from(blocks.keys()).sort((a, b) => {
        const oa = blockOrder(a);
        const ob = blockOrder(b);
        if (oa[0] !== ob[0]) return oa[0] - ob[0];
        if (oa[1] !== ob[1]) return oa[1] < ob[1] ? -1 : oa[1] > ob[1] ? 1 : 0;
        return a.localeCompare(b);
      });

      const nodeMetaStr = (node) => {
        if (state.displayMode === "memory") {
          return node.has_memory_data
            ? `batched_in: ${node.self_batched_in.toLocaleString()}, merges: ${node.self_merges.toLocaleString()}, merge_in: ${node.self_merge_in.toLocaleString()}, merge_out: ${node.self_merge_out.toLocaleString()}, dropped: ${node.self_dropped.toLocaleString()}`
            : "no memory data";
        }
        return `${fmtMs(node.self_total_active_ms)} ms, ${node.self_activations} act`;
      };

      function renderNodeRow(name, depth = 0) {
        const node = nodes[name];
        if (state.search && !nodeMatches(name, node)) return;
        const row = document.createElement("div");
        row.className = "tree-node" + (state.selected === name ? " selected" : "");
        row.dataset.name = name;
        row.style.paddingLeft = `${12 + depth * 16}px`;
        row.onclick = () => selectNode(name);
        row.innerHTML = `${escapeHtml(node.label)} <span class="muted">(${nodeMetaStr(node)})</span>`;
        root.appendChild(row);
      }

      function renderRuleHeader(title) {
        const hdr = document.createElement("div");
        hdr.className = "muted";
        hdr.style.padding = "4px 0 2px 0";
        hdr.textContent = title;
        root.appendChild(hdr);
      }

      const planMatchMemo = new Map();

      function planNodeMatches(rule, fp, visiting = new Set()) {
        const key = planKey(rule.text, fp);
        if (planMatchMemo.has(key)) return planMatchMemo.get(key);
        const pn = rule.nodes?.[fp];
        if (!pn) {
          planMatchMemo.set(key, false);
          return false;
        }
        if (visiting.has(fp)) return false; // avoid cycles

        const useParents = (rule.nodes?.[rule.root]?.children || []).length === 0;
        const nextEdges = useParents ? pn.parents || [] : pn.children || [];

        let matched = false;
        const name = pn.node;
        if (name && nodes[name] && nodeMatches(name, nodes[name])) {
          matched = true;
        }

        if (!matched) {
          visiting.add(fp);
          for (const child of nextEdges) {
            if (planNodeMatches(rule, child, visiting)) {
              matched = true;
              break;
            }
          }
          visiting.delete(fp);
        }

        planMatchMemo.set(key, matched);
        return matched;
      }

      function renderPlanNode(rule, fp, depth, visiting = new Set()) {
        const pn = rule.nodes?.[fp];
        if (!pn) return;

        if (state.search && !planNodeMatches(rule, fp, new Set())) return;

        const useParents = (rule.nodes?.[rule.root]?.children || []).length === 0;
        const nextEdges = useParents ? pn.parents || [] : pn.children || [];

        const key = planKey(rule.text, fp);
        if (autoExpand && nextEdges.length) {
          state.expanded.add(key);
        }

        const name = pn.node;
        const node = name ? nodes[name] : null;
        const hasChildren = nextEdges.length > 0;
        const expanded = hasChildren && state.expanded.has(key);

        const row = document.createElement("div");
        row.className = "tree-node" + (state.selected === name ? " selected" : "");
        row.dataset.name = name || fp;
        row.dataset.rule = rule.text;
        row.dataset.fp = fp;

        const indent = '<span class="indent"></span>'.repeat(depth);
        const toggle = hasChildren
          ? `<span class="toggle" data-toggle="1">${expanded ? "▾" : "▸"}</span>`
          : '<span class="toggle"></span>';

        const labelText = node?.label || pn.label || name || pn.fingerprint || fp;
        const shared = pn.shared ? ' <span class="muted">[shared]</span>' : "";
        const meta = node
          ? ` <span class="muted">(${nodeMetaStr(node)})</span>`
          : "";

        row.innerHTML = `${indent}${toggle}${escapeHtml(labelText)}${shared}${meta}`;

        row.onclick = (e) => {
          if (e.target?.dataset?.toggle === "1") {
            if (expanded) state.expanded.delete(key);
            else state.expanded.add(key);
            renderTree();
            return;
          }
          if (name) selectNode(name, rule.text);
        };

        root.appendChild(row);

        if (!hasChildren || !expanded) return;

        const ordered = [...nextEdges].sort((a, b) => a.localeCompare(b));
        for (const child of ordered) {
          if (visiting.has(child)) {
            const cyc = document.createElement("div");
            cyc.className = "tree-node muted";
            cyc.style.paddingLeft = `${12 + (depth + 1) * 16}px`;
            cyc.textContent = `(cycle to ${child})`;
            root.appendChild(cyc);
            continue;
          }
          const next = new Set(visiting);
          next.add(fp);
          renderPlanNode(rule, child, depth + 1, next);
        }
      }

      for (const blk of sortedBlocks) {
        const title = document.createElement("div");
        title.style.fontWeight = "600";
        title.style.padding = "6px 0 4px 0";
        title.textContent = blk;
        root.appendChild(title);

        const names = blocks.get(blk) || [];
        const isStratum = /^stratum\s+/i.test(blk);

        if (isStratum) {
          const runtimeNodes = [];
          const ruleNodesByText = new Map();

          for (const n of names) {
            const fp = nodes[n]?.fingerprint || null;
            const matches = fp ? rulesForFingerprint(fp) : [];
            if (!matches.length) {
              runtimeNodes.push(n);
              continue;
            }
            for (const r of matches) {
              if (!ruleNodesByText.has(r)) ruleNodesByText.set(r, new Set());
              ruleNodesByText.get(r).add(n);
            }
          }

          // Render rules in spec order for stability.
          for (const rule of rules) {
            const r = rule.text;
            const set = ruleNodesByText.get(r);
            if (!set || set.size === 0) continue;

            renderRuleHeader(`${r}`);

            if (rule.root && rule.nodes?.[rule.root]) {
              renderPlanNode(rule, rule.root, 0);
            } else {
              Array.from(set).sort(cmpById).forEach((n) => renderNodeRow(n));
            }
          }

          if (runtimeNodes.length) {
            renderRuleHeader("runtime");
            runtimeNodes.sort(cmpById).forEach((n) => renderNodeRow(n));
          }
        } else {
          names.sort(cmpById).forEach((n) => renderNodeRow(n));
        }
      }

      if (autoExpand) state.defaultExpanded = true;
    }

    function renderGraph() {
      const container = document.getElementById("graphView");
      const nodes = DATA.nodes;
      const allNames = Object.keys(nodes);

      function blockOf(node) {
        if (node.block) return node.block;
        return "other";
      }

      function blockRank(block) {
        if (!block) return 0;
        const b = String(block).toLowerCase();
        if (b.startsWith("input")) return 0;
        const m = b.match(/^stratum\s*(\d+)/);
        if (m) return 1 + parseInt(m[1], 10);
        if (b.includes("inspect")) return 1000;
        return 500;
      }

      function uniqueBlocksInOrder() {
        const set = new Set();
        for (const name of allNames) set.add(blockOf(nodes[name]));
        return Array.from(set).sort(
          (a, b) =>
            blockRank(a) - blockRank(b) || String(a).localeCompare(String(b))
        );
      }

      function nodeLabelFor(name) {
        const n = nodes[name];
        return n?.label || name;
      }

      const sizeByName = new Map();
      for (const name of allNames) {
        sizeByName.set(name, nodeBox(nodeLabelFor(name)));
      }

      function nodeHalfH(name) {
        const { h } = sizeByName.get(name) || { h: NODE.minH };
        return h / 2;
      }

      const hasDagParents = allNames.some((n) => nodes[n]?.dag_parents !== undefined);

      // --- Build DAG edges (parent -> child) ---
      const parents = new Map(); // child -> [parents...]
      const children = new Map(); // parent -> [children...]
      const indeg = new Map();

      for (const n of allNames) {
        parents.set(n, []);
        children.set(n, []);
        indeg.set(n, 0);
      }

      if (!hasDagParents) {
        throw new Error("Missing dag_parents in report data");
      }

      for (const v of allNames) {
        const ps = nodes[v]?.dag_parents || [];
        for (const p of ps) {
          if (!nodes[p]) continue;
          parents.get(v).push(p);
          children.get(p).push(v);
          indeg.set(v, (indeg.get(v) ?? 0) + 1);
        }
      }

      // --- Topological order (Kahn). If cycle exists, still render with fallback. ---
      const q = [];
      for (const n of allNames) {
        if ((indeg.get(n) ?? 0) === 0) q.push(n);
      }

      const topo = [];
      while (q.length) {
        const u = q.shift();
        topo.push(u);
        for (const v of children.get(u) || []) {
          indeg.set(v, indeg.get(v) - 1);
          if (indeg.get(v) === 0) q.push(v);
        }
      }

      if (topo.length !== allNames.length) {
        const seen = new Set(topo);
        const rest = allNames.filter((n) => !seen.has(n)).sort();
        topo.push(...rest);
      }

      // --- Depth = max(parent depth) + 1 (ensures below *all* parents) ---
      const depth = new Map();
      for (const n of allNames) {
        const blk = blockOf(nodes[n]);
        depth.set(n, blockRank(blk));
      }
      for (const r of DATA.roots || []) {
        const blk = blockOf(nodes[r]);
        depth.set(r, blockRank(blk));
      }

      for (const v of topo) {
        let d = depth.get(v) ?? 0;
        for (const p of parents.get(v) || []) {
          const pd = depth.get(p) ?? 0;
          d = Math.max(d, pd + 1);
        }
        const blk = blockOf(nodes[v]);
        d = Math.max(d, blockRank(blk));
        depth.set(v, d);
      }

      // --- Group into layers by depth ---
      const layers = new Map(); // depth -> [names]
      for (const n of allNames) {
        const d = depth.get(n) ?? 0;
        if (!layers.has(d)) layers.set(d, []);
        layers.get(d).push(n);
      }

      for (const list of layers.values()) list.sort();
      const layerKeys = [...layers.keys()].sort((a, b) => a - b);

      // --- Order within layers: barycenter heuristic to reduce crossings ---
      function barycenterSortDown() {
        for (let i = 1; i < layerKeys.length; i++) {
          const d = layerKeys[i];
          const prev = layers.get(layerKeys[i - 1]) || [];
          const idxPrev = new Map(prev.map((n, j) => [n, j]));

          const cur = layers.get(d) || [];
          cur.sort((a, b) => {
            const pa = parents.get(a) || [];
            const pb = parents.get(b) || [];
            const ba =
              pa.length === 0
                ? Number.POSITIVE_INFINITY
                : pa.reduce((s, p) => s + (idxPrev.get(p) ?? 0), 0) / pa.length;
            const bb =
              pb.length === 0
                ? Number.POSITIVE_INFINITY
                : pb.reduce((s, p) => s + (idxPrev.get(p) ?? 0), 0) / pb.length;

            if (ba !== bb) return ba - bb;
            return a.localeCompare(b);
          });
        }
      }

      function barycenterSortUp() {
        for (let i = layerKeys.length - 2; i >= 0; i--) {
          const d = layerKeys[i];
          const next = layers.get(layerKeys[i + 1]) || [];
          const idxNext = new Map(next.map((n, j) => [n, j]));

          const cur = layers.get(d) || [];
          cur.sort((a, b) => {
            const ca = children.get(a) || [];
            const cb = children.get(b) || [];
            const ba =
              ca.length === 0
                ? Number.POSITIVE_INFINITY
                : ca.reduce((s, c) => s + (idxNext.get(c) ?? 0), 0) / ca.length;
            const bb =
              cb.length === 0
                ? Number.POSITIVE_INFINITY
                : cb.reduce((s, c) => s + (idxNext.get(c) ?? 0), 0) / cb.length;

            if (ba !== bb) return ba - bb;
            return a.localeCompare(b);
          });
        }
      }

      barycenterSortDown();
      barycenterSortUp();
      barycenterSortDown();

      // --- Compute positions (initial centers) ---
      const layerGap = 150;
      const minGap = 40;
      const layerWidths = new Map();
      let width = 960;
      for (const d of layerKeys) {
        const list = layers.get(d) || [];
        const totalNodesW = list.reduce((s, n) => s + (sizeByName.get(n)?.w || NODE.minW), 0);
        const totalW = totalNodesW + (list.length + 1) * minGap;
        layerWidths.set(d, totalW);
        width = Math.max(width, totalW);
      }

      const pos = new Map();
      for (let li = 0; li < layerKeys.length; li++) {
        const d = layerKeys[li];
        const list = layers.get(d) || [];
        const totalW = layerWidths.get(d) || width;
        let x = (width - totalW) / 2 + minGap;
        list.forEach((name) => {
          const w = sizeByName.get(name)?.w || NODE.minW;
          x += w / 2;
          pos.set(name, { x, y: 40 + li * layerGap });
          x += w / 2 + minGap;
        });
      }

      // --- Separate blocks vertically to avoid overlapping group rectangles ---
      const BLOCK_PAD = 28; // should match your block padding below
      const BLOCK_GAP = 64; // extra spacing between blocks (tweak)
      const blocksOrdered = uniqueBlocksInOrder();

      // Map block -> [node names]
      const namesByBlock = new Map();
      for (const name of allNames) {
        const blk = blockOf(nodes[name]);
        if (!namesByBlock.has(blk)) namesByBlock.set(blk, []);
        namesByBlock.get(blk).push(name);
      }

      let prevMaxY = -Infinity;

      for (const blk of blocksOrdered) {
        const names = namesByBlock.get(blk) || [];
        if (names.length === 0) continue;

        let minY = Infinity;
        let maxY = -Infinity;

        for (const name of names) {
          const p = pos.get(name);
          if (!p) continue;
          const hh = nodeHalfH(name);
          minY = Math.min(minY, p.y - hh - BLOCK_PAD);
          maxY = Math.max(maxY, p.y + hh + BLOCK_PAD);
        }

        if (prevMaxY !== -Infinity && minY < prevMaxY + BLOCK_GAP) {
          const delta = prevMaxY + BLOCK_GAP - minY;

          for (const name of names) {
            const p = pos.get(name);
            if (p) p.y += delta;
          }

          minY += delta;
          maxY += delta;
        }

        prevMaxY = Math.max(prevMaxY, maxY);
      }

      // Adjust height after shifting blocks.
      let maxY = 0;
      for (const p of pos.values()) maxY = Math.max(maxY, p.y);
      const height = Math.max(layerKeys.length * layerGap + 80, maxY + 160);

      // --- Measure + place nodes (auto-sized) ---
      const boxByName = new Map(); // name -> {x0,y0,w,h,cx,cy,lines}
      for (const [name, node] of Object.entries(nodes)) {
        const p = pos.get(name);
        if (!p) continue;
        const { w, h, lines } = sizeByName.get(name) || nodeBox(node.label || name);
        boxByName.set(name, {
          x0: p.x - w / 2,
          y0: p.y - h / 2,
          w,
          h,
          cx: p.x,
          cy: p.y,
          lines,
        });
      }


      // --- Compute block bounding boxes (with padding) ---
      const blockBoxes = new Map(); // block -> {x0,y0,x1,y1}
      const pad = BLOCK_PAD;
      for (const [name, node] of Object.entries(nodes)) {
        const b = boxByName.get(name);
        if (!b) continue;
        const blk = blockOf(node);
        const bb = blockBoxes.get(blk) || {
          x0: Infinity,
          y0: Infinity,
          x1: -Infinity,
          y1: -Infinity,
        };
        bb.x0 = Math.min(bb.x0, b.x0 - pad);
        bb.y0 = Math.min(bb.y0, b.y0 - pad);
        bb.x1 = Math.max(bb.x1, b.x0 + b.w + pad);
        bb.y1 = Math.max(bb.y1, b.y0 + b.h + pad);
        blockBoxes.set(blk, bb);
      }

      // Node color scale based on self time or memory (batched_in).
      const maxMs = Math.max(
        ...Object.values(nodes).map((n) => n.self_total_active_ms || 0),
        0.0001
      );
      const maxBatchedIn = Math.max(
        ...Object.values(nodes).map((n) => n.self_batched_in || 0),
        1
      );

      function nodeColor(node) {
        if (state.displayMode === "memory") {
          if (!node.has_memory_data) return "rgb(255,255,255)";
          const t = Math.min(1, (node.self_batched_in || 0) / maxBatchedIn);
          const c1 = [255, 255, 255];
          const c2 = [220, 30, 30];
          const mix = c1.map((v, i) => Math.round(v + (c2[i] - v) * t));
          return `rgb(${mix[0]},${mix[1]},${mix[2]})`;
        }
        const t = Math.min(1, (node.self_total_active_ms || 0) / maxMs);
        const c1 = [233, 242, 255];
        const c2 = [91, 141, 239];
        const mix = c1.map((v, i) => Math.round(v + (c2[i] - v) * t));
        return `rgb(${mix[0]},${mix[1]},${mix[2]})`;
      }

      const childOrder = new Map();
      const parentOrder = new Map();

      for (const [p, kids] of children.entries()) {
        const ordered = [...kids].sort((a, b) => {
          const ax = pos.get(a)?.x ?? 0;
          const bx = pos.get(b)?.x ?? 0;
          return ax - bx || a.localeCompare(b);
        });
        childOrder.set(p, ordered);
      }

      for (const [c, ps] of parents.entries()) {
        const ordered = [...ps].sort((a, b) => {
          const ax = pos.get(a)?.x ?? 0;
          const bx = pos.get(b)?.x ?? 0;
          return ax - bx || a.localeCompare(b);
        });
        parentOrder.set(c, ordered);
      }

      function edgeOffset(list, name) {
        const n = list.length;
        if (n <= 1) return 0;
        const i = Math.max(0, list.indexOf(name));
        return (i - (n - 1) / 2) * 8;
      }

      function edgePath(x1, y1, x2, y2) {
        const dy = Math.max(30, (y2 - y1) / 2);
        return `M ${x1} ${y1} C ${x1} ${y1 + dy} ${x2} ${y2 - dy} ${x2} ${y2}`;
      }

      // --- Build edges as paths from box boundary to box boundary ---
      let edges = "";
      for (const [name, node] of Object.entries(nodes)) {
        const from = boxByName.get(name);
        if (!from) continue;
        const kids = children.get(name) || [];
        for (const c of kids) {
          const to = boxByName.get(c);
          if (!to) continue;
          const fromList = childOrder.get(name) || [];
          const toList = parentOrder.get(c) || [];
          const x1 = from.cx + edgeOffset(fromList, c);
          const y1 = from.y0 + from.h;
          const x2 = to.cx + edgeOffset(toList, name);
          const y2 = to.y0;
          edges += `<path class="g-edge" data-from="${name}" data-to="${c}" d="${edgePath(
            x1,
            y1,
            x2,
            y2
          )}" />`;
        }
      }

      // --- Build block rectangles ---
      let blocks = "";
      const blockPalette = [
        "rgba(233, 242, 255, 0.55)",
        "rgba(248, 241, 255, 0.55)",
        "rgba(240, 252, 244, 0.55)",
        "rgba(255, 248, 235, 0.55)",
      ];
      const blockNames = Array.from(blockBoxes.keys()).sort(
        (a, b) =>
          blockRank(a) - blockRank(b) || String(a).localeCompare(String(b))
      );

      // Legend: show color scale appropriate to display mode.
      const legendEl = document.getElementById("legend");
      if (legendEl) {
        if (state.displayMode === "memory") {
          legendEl.innerHTML = `<span class="legend-item"><span class="legend-swatch-red"></span><span>memory (batched_in): none (white) → high (red, max ${maxBatchedIn.toLocaleString()})</span></span>`;
        } else {
          legendEl.innerHTML = `<span class="legend-item"><span class="legend-swatch"></span><span>time (ms): low → high (max ${fmtMs(
            maxMs
          )})</span></span>`;
        }
      }

      blockNames.forEach((blk, idx) => {
        const bb = blockBoxes.get(blk);
        if (!bb) return;
        const fill = blockPalette[idx % blockPalette.length];
        const w = Math.max(120, bb.x1 - bb.x0);
        const h = Math.max(80, bb.y1 - bb.y0);
        const labelX = bb.x0 + 10;
        const labelY = bb.y0 - 8;
        blocks += `
      <g class="g-block">
        <rect x="${bb.x0}" y="${bb.y0}" width="${w}" height="${h}" fill="${fill}"></rect>
        <text x="${labelX}" y="${labelY}" font-size="12" fill="#445" font-weight="600">${escapeHtml(
          blk
        )}</text>
      </g>`;
      });

      // --- Build vertices with wrapped text ---
      let verts = "";
      for (const [name, node] of Object.entries(nodes)) {
        const b = boxByName.get(name);
        if (!b) continue;

        const isSel = state.selected === name;
        const ms = node.self_total_active_ms || 0;
        const labelEsc = escapeHtml(node.label || name);

        let nodeTip;
        if (state.displayMode === "memory") {
          if (node.has_memory_data) {
            nodeTip = `${labelEsc}\nbatched_in: ${node.self_batched_in.toLocaleString()}\nmerges: ${node.self_merges.toLocaleString()}\nmerge_in: ${node.self_merge_in.toLocaleString()}\nmerge_out: ${node.self_merge_out.toLocaleString()}\ndropped: ${node.self_dropped.toLocaleString()}`;
          } else {
            nodeTip = `${labelEsc}\n(no memory data)`;
          }
        } else {
          nodeTip = `${labelEsc}\ntime: ${fmtMs(ms)}\nactivations: ${node.self_activations}`;
        }

        const tspans = b.lines
          .map((ln, i) => {
            const safe = escapeHtml(ln);
            const dy = i === 0 ? 0 : NODE.lineH;
            return `<tspan x="${b.w / 2}" dy="${dy}">${safe}</tspan>`;
          })
          .join("");

        const textY0 = NODE.padY + 12;

        verts += `
      <g class="g-node${isSel ? " selected" : ""}" data-name="${name}" transform="translate(${b.x0}, ${b.y0})">
        <rect width="${b.w}" height="${b.h}" fill="${nodeColor(node)}"></rect>
        <text x="${b.w / 2}" y="${textY0}" text-anchor="middle">${tspans}</text>
        <title>${nodeTip}</title>
      </g>`;
      }

      container.innerHTML = `
    <svg id="graphSvg" viewBox="0 0 ${width} ${height}">
      <g id="viewport">
        ${blocks}
        ${edges}
        ${verts}
      </g>
    </svg>
  `;

      const svg = document.getElementById("graphSvg");
      const viewport = document.getElementById("viewport");
      const edgeEls = Array.from(svg.querySelectorAll(".g-edge"));

      function applyTransform() {
        viewport.setAttribute(
          "transform",
          `translate(${state.graph.tx} ${state.graph.ty}) scale(${state.graph.scale})`
        );
      }
      let rafPending = false;
      function scheduleApplyTransform() {
        if (rafPending) return;
        rafPending = true;
        requestAnimationFrame(() => {
          rafPending = false;
          applyTransform();
        });
      }

      applyTransform();

      // Click-to-select still works.
      svg.addEventListener("click", (e) => {
        const g = e.target.closest(".g-node");
        if (!g) return;
        const name = g.getAttribute("data-name");
        if (name) selectNode(name);
      });

      // Double-click on blank area resets selection.
      svg.addEventListener("dblclick", (e) => {
        const g = e.target.closest(".g-node");
        if (g) return;
        state.selected = null;
        state.selectedRule = null;
        clearEdgeFocus();
        renderTree();
        renderTopNodes();
        renderGraph();
      });

      function focusEdges(name) {
        edgeEls.forEach((el) => {
          const from = el.getAttribute("data-from");
          const to = el.getAttribute("data-to");
          if (from === name || to === name) {
            el.classList.add("highlight");
            el.classList.remove("dim");
          } else {
            el.classList.add("dim");
            el.classList.remove("highlight");
          }
        });
      }

      function clearEdgeFocus() {
        edgeEls.forEach((el) => {
          el.classList.remove("dim");
          el.classList.remove("highlight");
        });
      }

      // --- Pan (drag) ---
      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      svg.addEventListener("pointerdown", (e) => {
        if (e.button !== 0) return;
        if (e.target.closest(".g-node")) return; // avoid starting pan on node click
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        svg.setPointerCapture(e.pointerId);
      });

      svg.addEventListener("pointermove", (e) => {
        if (!dragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;

        // Pan in screen-space with a boost at higher zoom levels.
        const panBoost = Math.max(1, Math.sqrt(state.graph.scale));
        state.graph.tx += dx * panBoost;
        state.graph.ty += dy * panBoost;
        scheduleApplyTransform();
      });

      svg.addEventListener("pointerup", () => {
        dragging = false;
      });
      svg.addEventListener("pointercancel", () => {
        dragging = false;
      });

      // --- Zoom (wheel) ---
      svg.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();

          const oldScale = state.graph.scale;
          const factor = Math.exp(-e.deltaY * 0.0012);
          let newScale = oldScale * factor;
          newScale = Math.max(0.1, Math.min(10.0, newScale));
          if (newScale === oldScale) return;

          // Zoom around cursor (keep point under mouse stable).
          const pt = svg.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const cursor = pt.matrixTransform(svg.getScreenCTM().inverse());

          const k = newScale / oldScale;
          state.graph.tx = state.graph.tx + (cursor.x - state.graph.tx) * (1 - k);
          state.graph.ty = state.graph.ty + (cursor.y - state.graph.ty) * (1 - k);
          state.graph.scale = newScale;

          scheduleApplyTransform();
        },
        { passive: false }
      );

      if (state.selected) focusEdges(state.selected);
    }

    // Ensure a selected node is visible in the left list and scroll to it.
    function ensureTreeVisible(name, ruleText = null, fp = null) {
      let row = null;
      if (fp && ruleText) {
        row = document.querySelector(
          `#tree .tree-node[data-fp="${CSS.escape(fp)}"][data-rule="${CSS.escape(ruleText)}"]`
        );
      }
      if (!row) {
        row = document.querySelector(`#tree .tree-node[data-name="${CSS.escape(name)}"]`);
      }
      row?.scrollIntoView({ block: "center", behavior: "smooth" });
    }

    function renderRulePicker(name, fp, matches, selectedRule) {
      const el = document.getElementById("rulePicker");
      if (!fp || !matches.length) {
        el.innerHTML = "";
        return;
      }
      if (matches.length === 1) {
        el.innerHTML = `<div class="rule-single">${escapeHtml(matches[0])}</div>`;
        return;
      }

      const buttons = matches
        .map((r) => {
          const active = r === selectedRule;
          return `<button data-rule="${escapeHtml(r)}" class="rule-item${active ? " active" : ""
            }">${escapeHtml(r)}</button>`;
        })
        .join("");

      el.innerHTML = `Shared in ${matches.length} rules:<div class="rule-list">${buttons}</div>`;
      el.querySelectorAll("button[data-rule]").forEach((btn) => {
        btn.onclick = () => selectNode(name, btn.dataset.rule);
      });
    }

    function renderTopNodes() {
      const container = document.getElementById("topNodes");
      const titleEl = document.querySelector(".toplist-title");

      // Memory mode
      if (state.displayMode === "memory") {
        if (titleEl) titleEl.textContent = "Top 10 by Memory";
        const memNodes = Object.entries(DATA.nodes || {})
          .map(([name, node]) => ({ name, node }))
          .filter((x) => x.node.has_memory_data)
          .sort((a, b) => b.node.self_batched_in - a.node.self_batched_in)
          .slice(0, 10);

        if (!memNodes.length) {
          container.innerHTML = "<div class=\"muted\">No memory data.</div>";
          return;
        }

        container.innerHTML = memNodes
          .map(({ name, node }) => {
            const active = state.selected === name ? " active" : "";
            const label = node.label || name;
            return `
        <div class="toplist-item${active}" data-name="${escapeHtml(name)}">
          <div class="toplist-name" title="${escapeHtml(label)}">${escapeHtml(label)}</div>
          <div class="toplist-ms">${node.self_batched_in.toLocaleString()}</div>
        </div>`;
          })
          .join("");

        container.querySelectorAll(".toplist-item").forEach((row) => {
          row.onclick = () => selectNode(row.dataset.name);
        });
        return;
      }

      // Time mode (default)
      if (titleEl) titleEl.textContent = "Top 10 by Time";
      const nodes = Object.entries(DATA.nodes || {})
        .map(([name, node]) => ({ name, node }))
        .filter((x) => typeof x.node?.self_total_active_ms === "number")
        .sort((a, b) => b.node.self_total_active_ms - a.node.self_total_active_ms)
        .slice(0, 10);

      if (!nodes.length) {
        container.innerHTML = "<div class=\"muted\">No timing data.</div>";
        return;
      }

      container.innerHTML = nodes
        .map(({ name, node }) => {
          const active = state.selected === name ? " active" : "";
          const label = node.label || name;
          return `
        <div class="toplist-item${active}" data-name="${escapeHtml(name)}">
          <div class="toplist-name" title="${escapeHtml(label)}">${escapeHtml(label)}</div>
          <div class="toplist-ms">${fmtMs(node.self_total_active_ms)} ms</div>
        </div>`;
        })
        .join("");

      container.querySelectorAll(".toplist-item").forEach((row) => {
        row.onclick = () => selectNode(row.dataset.name);
      });
    }

    function selectNode(name, preferredRule = null) {
      state.selected = name;

      const node = DATA.nodes[name];
      document.getElementById("title").textContent = node.label;

      const fp = node.fingerprint || null;
      const matches = fp ? rulesForFingerprint(fp) : [];

      let chosenRule = null;
      if (preferredRule && matches.includes(preferredRule)) {
        chosenRule = preferredRule;
      } else if (state.selectedRule && matches.includes(state.selectedRule)) {
        chosenRule = state.selectedRule;
      } else {
        chosenRule = matches[0] || null;
      }
      state.selectedRule = chosenRule;

      // Ensure the corresponding plan tree is expanded so the node is visible.
      if (chosenRule && fp) {
        const ruleObj = findRuleByText(chosenRule);
        if (ruleObj && ruleObj.nodes) {
          for (const [rfp, pn] of Object.entries(ruleObj.nodes)) {
            const hasEdges = (pn.children && pn.children.length) || (pn.parents && pn.parents.length);
            if (hasEdges) state.expanded.add(planKey(chosenRule, rfp));
          }
        }
      }

      const extra =
        node.extra_parents && node.extra_parents.length
          ? ` extra parents: ${node.extra_parents.join(", ")}`
          : "";
      const sharedLabel = matches.length > 1 ? ` | shared in ${matches.length} rules` : "";

      const memInfo = node.has_memory_data
        ? ` | batched_in: ${node.self_batched_in.toLocaleString()} | merges: ${node.self_merges.toLocaleString()} | merge_in: ${node.self_merge_in.toLocaleString()} | merge_out: ${node.self_merge_out.toLocaleString()} | dropped: ${node.self_dropped.toLocaleString()}`
        : "";

      document.getElementById("meta").textContent =
        `id: ${name} | time: ${fmtMs(node.self_total_active_ms)} ms | activations: ${node.self_activations}${memInfo}` +
        sharedLabel +
        extra;

      renderRulePicker(name, fp, matches, chosenRule);

      const tbl = document.getElementById("opsTable");
      const body = document.getElementById("opsBody");
      body.innerHTML = "";

      const head = document.getElementById("opsTableHead");
      const showMemCol = true;
      head.innerHTML = `<tr>
        <th>addr</th>
        <th>operator</th>
        <th class="num">activations</th>
        <th class="num">active time</th>
        ${showMemCol ? '<th class="num">batched_in</th><th class="num">merges</th><th class="num">merge_in</th><th class="num">merge_out</th><th class="num">dropped</th>' : ""}
      </tr>`;

      if (!node.operators || node.operators.length === 0) {
        tbl.style.display = "none";
      } else {
        tbl.style.display = "table";
        for (const op of node.operators) {
          const tr = document.createElement("tr");
          const memFmt = (v) => (v !== null && v !== undefined ? v.toLocaleString() : "—");
          const memCells = showMemCol
            ? `<td class="num">${memFmt(op.batched_in)}</td><td class="num">${memFmt(op.merges)}</td><td class="num">${memFmt(op.merge_in)}</td><td class="num">${memFmt(op.merge_out)}</td><td class="num">${memFmt(op.dropped)}</td>`
            : "";
          tr.innerHTML = `
        <td><code>[${op.addr.join(", ")}]</code></td>
        <td>${escapeHtml(op.op_name)}</td>
        <td class="num">${op.activations}</td>
        <td class="num">${fmtMs(op.total_active_ms)}</td>
        ${memCells}
      `;
          body.appendChild(tr);
        }
      }

      renderTree();
      ensureTreeVisible(name, chosenRule, fp);
      renderGraph();
      renderTopNodes();
    }

    function expandAll() {
      state.expanded.clear();
      for (const rule of DATA.rules || []) {
        if (!rule.nodes) continue;
        for (const [fp, pn] of Object.entries(rule.nodes)) {
          if (pn.children && pn.children.length) {
            state.expanded.add(planKey(rule.text, fp));
          }
        }
      }
      state.defaultExpanded = true;
      renderTree();
    }

    function collapseAll() {
      state.expanded.clear();
      state.defaultExpanded = true;
      renderTree();
    }

    document.getElementById("search").addEventListener("input", (e) => {
      state.search = e.target.value || "";
      renderTree();
    });

    document.getElementById("expandAll").onclick = expandAll;
    document.getElementById("collapseAll").onclick = collapseAll;

    document.getElementById("tabTree").onclick = () => {
      state.view = "tree";
      document.getElementById("detailPane").style.display = "block";
      document.getElementById("graphPane").style.display = "none";
      document.getElementById("tabTree").classList.add("active");
      document.getElementById("tabGraph").classList.remove("active");
    };

    document.getElementById("tabGraph").onclick = () => {
      state.view = "graph";
      document.getElementById("detailPane").style.display = "none";
      document.getElementById("graphPane").style.display = "flex"; // important
      document.getElementById("tabGraph").classList.add("active");
      document.getElementById("tabTree").classList.remove("active");
      renderGraph();
    };

    function setDisplayMode(mode) {
      state.displayMode = mode;
      document.getElementById("modeTime").classList.toggle("active", mode === "time");
      document.getElementById("modeMemory").classList.toggle("active", mode === "memory");
      renderTree();
      renderTopNodes();
      if (state.view === "graph") renderGraph();
    }

    document.getElementById("modeTime").onclick = () => setDisplayMode("time");
    document.getElementById("modeMemory").onclick = () => setDisplayMode("memory");

    renderSummary();
    renderTree();
    renderTopNodes();

    // Show mode toggle only when memory data is available.
    document.getElementById("modeToggle").style.display = "flex";

    if (DATA.roots.length) selectNode(DATA.roots[0]);
  </script>
</body>

</html>